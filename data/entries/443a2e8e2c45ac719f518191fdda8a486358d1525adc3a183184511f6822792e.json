{"title":"How To Use MDX Stored In Sanity In A Next.js Website","link":"https://smashingmagazine.com/2020/12/mdx-stored-sanity-next-js-website/","date":1607349600000,"content":"<p>Recently, my team took on a project to build an online, video-based learning platform. The project, called <a href=\"https://explorers.netlify.com?utm_source=smashingmag&amp;utm_medium=sanity-next-mdx-jl&amp;utm_campaign=devex\">Jamstack Explorers</a>, is a Jamstack app powered by Sanity and Next.js. We knew that the success of this project relied on making the editing experience easy for collaborators from different companies and roles, as well as retaining the flexibility to add custom components as needed.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/51df7478-6a24-4f61-8755-d6eed88f0600/jamstack-explorers.png\" /></p>\n<p>To accomplish this, we decided to author content using <a href=\"https://mdxjs.com/\">MDX</a>, which is <a href=\"https://www.markdownguide.org/\">Markdown</a> with the option to include custom components. For our audience, Markdown is a standard approach to writing content: itâ€™s how we format GitHub comments, Notion docs, Slack messages (kinda), and many other tools. The custom MDX components are optional and their usage is similar to shortcodes in WordPress and templating languages.</p>\n<p>To make it possible to collaborate with contributors from anywhere, we decided to use <a href=\"https://www.sanity.io/\">Sanity</a> as our content management system (CMS).</p>\n<p>But how could we write MDX in Sanity? In this tutorial, weâ€™ll break down how we set up MDX support in Sanity, and how to load and render that MDX in <a href=\"https://nextjs.org/\">Next.js</a> â€” powered website using a reduced example.</p>\n<h3>TL;DR</h3>\n\n<p>If you want to jump straight to the results, here are some helpful links:</p>\n<ul>\n<li>See the <a href=\"https://github.com/jlengstorf/sanity-next-mdx\">example repo used in this tutorial</a>.</li>\n<li>See this approach in action on <a href=\"https://explorers.netlify.com?utm_source=smashingmag&amp;utm_medium=sanity-next-mdx-jl&amp;utm_campaign=devex\">Jamstack Explorers</a>.</li>\n<li>Check out the <a href=\"https://github.com/netlify/explorers\">Jamstack Explorers source code</a>.</li>\n</ul>\n<h3>How To Write Content Using MDX In Sanity</h3>\n<p>Our first step is to get our content management workflow set up. In this section, weâ€™ll walk through setting up a new Sanity instance, adding support for writing MDX, and creating a public, read-only API that we can use to load our content into a website for display.</p>\n<h4>Create A New Sanity Instance</h4>\n<p>If you donâ€™t already have a Sanity instance set up, letâ€™s start with that. If you do already have a Sanity instance, skip ahead to the next section.</p>\n<p>Our first step is to <a href=\"https://www.sanity.io/docs/getting-started-with-sanity-cli\">install the Sanity CLI</a> globally, which allows us to install, configure, and run Sanity locally.</p>\n<pre><code># install the Sanity CLI\nnpm i -g @sanity/cli</code></pre>\n\n<p>In your project folder, create a new directory called sanity, move into it, and run Sanityâ€™s init command to create a new project.</p>\n<pre><code># create a new directory to contain Sanity files\nmkdir sanity\ncd sanity/\nsanity init</code></pre>\n\n<p>The init command will ask a series of questions. You can choose whatever makes sense for your project, but in this example weâ€™ll use the following options:</p>\n<ul>\n<li>Choose a project name: Sanity Next MDX Example.</li>\n<li>Choose the default dataset configuration (\"production\").</li>\n<li>Use the default project output path (the current directory).</li>\n<li>Choose \"clean project\" from the template options.</li>\n</ul>\n<h4>Install The Markdown Plugin For Sanity</h4>\n<p>By default, Sanity doesnâ€™t have Markdown support. Fortunately, thereâ€™s a ready-made <a href=\"https://www.sanity.io/plugins/sanity-plugin-markdown\">Sanity plugin for Markdown support</a> that we can install and configure with a single command:</p>\n<pre><code># add the Markdown plugin\nsanity install markdown</code></pre>\n\n<p>This command will install the plugin and add the appropriate configuration to your Sanity instance to make it available for use.</p>\n<h4>Define A Custom Schema With A Markdown Input</h4>\n<p>In Sanity, we control every content type and input using <a href=\"https://www.sanity.io/docs/content-modelling\">schemas</a>. This is one of my favorite features about Sanity, because it means that I have fine-grained control over what each content type stores, how that content is processed, and even how the content preview is built.</p>\n<p>For this example, weâ€™re going to create a simple page structure with a title, a slug to be used in the page URL, and a content area that expects Markdown.</p>\n<p>Create this schema by adding a new file at <code>sanity/schemas/page.js</code> and adding the following code:</p>\n<pre><code>export default {\n  name: 'page',\n  title: 'Page',\n  type: 'document',\n  fields: [\n    {\n      name: 'title',\n      title: 'Page Title',\n      type: 'string',\n      validation: (Rule) =&gt; Rule.required(),\n    },\n    {\n      name: 'slug',\n      title: 'Slug',\n      type: 'slug',\n      validation: (Rule) =&gt; Rule.required(),\n      options: {\n        source: 'title',\n        maxLength: 96,\n      },\n    },\n    {\n      name: 'content',\n      title: 'Content',\n      type: 'markdown',\n    },\n  ],\n};</code></pre>\n\n<p>We start by giving the whole content type a name and title. The type of document tells Sanity that this should be displayed at the top level of the Sanity Studio as a content type someone can create.</p>\n<p>Each field also needs a name, title, and type. We can optionally provide <a href=\"https://www.sanity.io/docs/validation\">validation rules</a> and other options, such as giving the slug a max length and allowing it to be generated from the title value.</p>\n<h4>Add A Custom Schema To Sanityâ€™s Configuration</h4>\n<p>After our schema is defined, we need to tell Sanity to use it. We do this by importing the schema into <code>sanity/schemas/schema.js</code>, then adding it to the <code>types</code> array passed to <code>createSchema</code>.</p>\n<div>\n<pre><code>\n  // First, we must import the schema creator\n  import createSchema from 'part:@sanity/base/schema-creator';\n\n  // Then import schema types from any plugins that might expose them\n  import schemaTypes from 'all:part:@sanity/base/schema-type';\n\n+ // Import custom schema types here\n+ import page from './page';\n\n  // Then we give our schema to the builder and provide the result to Sanity\n  export default createSchema({\n    // We name our schema\n    name: 'default',\n    // Then proceed to concatenate our document type\n    // to the ones provided by any plugins that are installed\n    types: schemaTypes.concat([\n-     /<em> Your types here! </em>/\n+     page,\n    ]),\n  });</code></pre>\n</div>\n\n<p>This puts our page schema into Sanityâ€™s startup configuration, which means weâ€™ll be able to create pages once we start Sanity up!</p>\n<h4>Run Sanity Studio Locally</h4>\n<p>Now that we have a schema defined and configured, we can start Sanity locally.</p>\n<pre><code>sanity start</code></pre>\n\n<p>Once itâ€™s running, we can open Sanity Studio at <code>http://localhost:3333</code> on our local machine.</p>\n<p>When we visit that URL, weâ€™ll need to log in the first time. Use your preferred account (e.g. GitHub) to authenticate. Once you get logged in, youâ€™ll see the Studio dashboard, which looks pretty barebones.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5d9c59d1-ce54-4b3b-bc54-c195d3aa4a92/sanity-studio-home.png\" /></p>\n<p>To add a new page, click \"Page\", then the pencil icon at the top-left.</p>\n<p>Add a title and slug, then write some Markdown with MDX in the content area:</p>\n<div>\n<pre><code>This is written in <a href=\"https://www.markdownguide.org/basic-syntax/\">Markdown</a>.\n\nBut whatâ€™s this?\n\n&lt;Callout&gt;\n\nOh dang! Is this a React component in the middle of our content? ðŸ˜±\n\n&lt;/Callout&gt;\n\nHoly buckets! Thatâ€™s amazing!</code></pre>\n</div>\n\n<blockquote>\n<p>Heads up! The empty line between the MDX component and the Markdown it contains is required. Otherwise the Markdown wonâ€™t be parsed. This will be <a href=\"https://github.com/mdx-js/mdx/issues/1041\">fixed in MDX v2</a>.</p>\n</blockquote>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/278a11c3-deb8-405c-a24f-e64d321ff2f6/sanity-studio-page-edit.png\" /></p>\n<p>Once you have the content in place, click \"Publish\" to make it available.</p>\n<h4>Deploy The Sanity Studio To A Production URL</h4>\n<p>In order to make edits to the siteâ€™s data without having to run the code locally, we need to deploy the Sanity Studio. The Sanity CLI makes this possible with a single command:</p>\n<pre><code>sanity deploy</code></pre>\n\n<p>Choose a hostname for the site, which will be used in the URL. After that, it will be deployed and reachable at your own custom link.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/902a46c1-29fa-46a3-a89c-7dab6f477a13/sanity-deploy-cli.png\" /></p>\n<p>This provides a production URL for content editors to log in and make changes to the site content.</p>\n<h4>Make Sanity Content Available Via GraphQL</h4>\n<p>Sanity ships with support for GraphQL, which weâ€™ll use to load our page data into our siteâ€™s front-end. To enable this, we need to deploy a GraphQL API, which is another one-liner:</p>\n<pre><code>sanity graphql deploy</code></pre>\n\n<p>We can choose to enable a GraphQL Playground, which gives us a browser-based data explorer. This is extremely handy for testing queries.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f3c3adf0-5a22-418f-a825-9b1ea1f42184/sanity-graphql-deploy-cli.png\" /></p>\n<p>Store the GraphQL URL â€” youâ€™ll need it to load the data into Next.js!</p>\n<pre><code>https://sqqecrvt.api.sanity.io/v1/graphql/production/default</code></pre>\n\n<p>The GraphQL API is read-only for published content by default, so we donâ€™t need to worry about keeping this secret â€” everything that this API returns is published, which means itâ€™s what we want people to see.</p>\n<h4>Test Sanity GraphQL Queries In The Browser</h4>\n<p>By opening the URL of our GraphQL API, weâ€™re able to test out GraphQL queries to make sure weâ€™re getting the data we expect. These queries are copy-pasteable into our code.</p>\n<p>To load our page data, we can build the following query using the \"schema\" tab at the right-hand side as a reference.</p>\n<pre><code>query AllPages {\n  allPage {\n    title\n    slug {\n      current\n    }\n    content\n  }\n}</code></pre>\n\n<p>This query loads all the pages published in Sanity, returning the title, current slug, and content for each. If we run this in the playground by pressing the play button, we can see our page returned.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e2021080-023f-4e33-bd83-a6f882b18660/sanity-graphql-playground.png\" /></p>\n<p>Now that weâ€™ve got page data with MDX in it coming back from Sanity, weâ€™re ready to build a site using it!</p>\n<p>In the next section, weâ€™ll create an Next.js site that loads data from Sanity and renders our MDX content properly.</p>\n<h3>Display MDX In Next.js From Sanity</h3>\n<p>In an empty directory, start by initializing a new <code>package.json</code>, then install Next, React, and a package called <code>next-mdx-remote</code>.</p>\n<pre><code># create a new package.json with the default options\nnpm init -y\n\n# install the packages we need for this project\nnpm i next react react-dom next-mdx-remote</code></pre>\n\n<p>Inside <code>package.json</code>, add a script to run <code>next dev</code>:</p>\n<pre><code>  {\n    \"name\": \"sanity-next-mdx\",\n    \"version\": \"1.0.0\",\n    \"scripts\": {\n+     \"dev\": \"next dev\"\n    },\n    \"author\": \"Jason Lengstorf &lt;jason@lengstorf.com&gt;\",\n    \"license\": \"ISC\",\n    \"dependencies\": {\n      \"next\": \"^10.0.2\",\n      \"next-mdx-remote\": \"^1.0.0\",\n      \"react\": \"^17.0.1\",\n      \"react-dom\": \"^17.0.1\"\n    }</code></pre>\n\n<h4>Create React Components To Use In MDX Content</h4>\n<p>In our page content, we used the <code>&lt;Callout&gt;</code> component to wrap some of our Markdown. MDX works by combining React components with Markdown, which means our first step is to define the React component our MDX expects.</p>\n<p>Create a Callout component at <code>src/components/callout.js</code>:</p>\n<pre><code>export default function Callout({ children }) {\n  return (\n    &lt;div\n      style={{\n        padding: '0 1rem',\n        background: 'lightblue',\n        border: '1px solid blue',\n        borderRadius: '0.5rem',\n      }}\n    &gt;\n      {children}\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<p>This component adds a blue box around content that we want to call out for extra attention.</p>\n<h4>Send GraphQL Queries Using The Fetch API</h4>\n<p>It may not be obvious, but you donâ€™t need a special library to send GraphQL queries! Itâ€™s possible to send a query to a GraphQL API using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">browserâ€™s built-in Fetch API</a>.</p>\n<p>Since weâ€™ll be sending a few GraphQL queries in our site, letâ€™s add a utility function that handles this so we donâ€™t have to duplicate this code in a bunch of places.</p>\n<p>Add a utility function to fetch Sanity data using the Fetch API at <code>src/utils/sanity.js</code>:</p>\n<pre><code>export async function getSanityContent({ query, variables = {} }) {\n  const { data } = await fetch(\n    'https://sqqecrvt.api.sanity.io/v1/graphql/production/default',\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        query,\n        variables,\n      }),\n    },\n  ).then((response) =&gt; response.json());\n\n  return data;\n}</code></pre>\n\n<p>The first argument is the Sanity GraphQL URL that Sanity returned when we deployed the GraphQL API.</p>\n<p>GraphQL queries are always sent using the <code>POST</code> method and the <code>application/json</code> content type header.</p>\n<p>The body of a GraphQL request is a stringified JSON object with two properties: query, which contains the query we want to execute as a string; and variables, which is an object containing any query variables we want to pass into the GraphQL query.</p>\n<p>The response will be JSON, so we need to handle that in the <code>.then</code> for the query result, and then we can destructure the result to get to the data inside. In a production app, weâ€™d want to check for errors in the result as well and display those errors in a helpful way, but this is a post about MDX, not GraphQL, so #yolo.</p>\n<p>Heads up! The Fetch API is great for simple use cases, but as your app becomes more complex youâ€™ll probably want to look into the benefits of using a GraphQL-specific tool like <a href=\"https://www.apollographql.com/docs/react/\">Apollo</a> or <a href=\"https://formidable.com/open-source/urql/\">urql</a>.</p>\n<h4>Create A Listing Of All Pages From Sanity In Next.js</h4>\n<p>To start, letâ€™s make a list of all the pages published in Sanity, as well as a link to their slug (which wonâ€™t work just yet).</p>\n<p>Create a new file at <code>src/pages/index.js</code> and put the following code inside:</p>\n<pre><code>import Link from 'next/link';\nimport { getSanityContent } from '../utils/sanity';\n\nexport default function Index({ pages }) {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;This Site Loads MDX From Sanity.io&lt;/h1&gt;\n      &lt;p&gt;View any of these pages to see it in action:&lt;/p&gt;\n      &lt;ul&gt;\n        {pages.map(({ title, slug }) =&gt; (\n          &lt;li key={slug}&gt;\n            &lt;Link href={`/${slug}`}&gt;\n              &lt;a&gt;{title}&lt;/a&gt;\n            &lt;/Link&gt;\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport async function getStaticProps() {\n  const data = await getSanityContent({\n    query: `\n      query AllPages {\n        allPage {\n          title\n          slug {\n            current\n          }\n        }\n      }\n    `,\n  });\n\n  const pages = data.allPage.map((page) =&gt; ({\n    title: page.title,\n    slug: page.slug.current,\n  }));\n\n  return {\n    props: { pages },\n  };\n}</code></pre>\n\n<p>In <code>getStaticProps</code> we call the <code>getSanityContent</code> utility with a query that loads the title and slug of all pages in Sanity. We then map over the page data to create a simplified object with a title and slug property for each page and return that array as a pages prop.</p>\n<p>The Index component to display this page receives that pageâ€™s prop, so we map over that to output an unordered list of links to the pages.</p>\n<p>Start the site with npm run dev and open <code>http://localhost:3000</code> to see the work in progress.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1d6560aa-b2e7-4d59-b9f5-8df118c1f6da/next-home-page-list.png\" /></p>\n<p>If we click a page link right now, weâ€™ll get a 404 error. In the next section weâ€™ll fix that!</p>\n<h4>Generate Pages Programatically In Next.js From CMS Data</h4>\n<p>Next.js supports <a href=\"https://nextjs.org/docs/routing/dynamic-routes\">dynamic routes</a>, so letâ€™s set up a new file to catch all pages except our home page at <code>src/pages/[page].js</code>.</p>\n<p>In this file, we need to tell Next what the slugs are that it needs to generate using the <code>getStaticPaths</code> function.</p>\n<p>To load the static content for these pages, we need to use <code>getStaticProps</code>, which will receive the current page slug in params.page.</p>\n<p>To help visualize whatâ€™s happening, weâ€™ll pass the slug through to our page and log the props out on screen for now.</p>\n<pre><code>import { getSanityContent } from '../utils/sanity';\n\nexport default function Page(props) {\n  return &lt;pre&gt;{JSON.stringify(props, null, 2)}&lt;/pre&gt;;\n}\n\nexport async function getStaticProps({ params }) {\n  return {\n    props: {\n      slug: params.page,\n    },\n  };\n}\n\nexport async function getStaticPaths() {\n  const data = await getSanityContent({\n    query: `\n      query AllPages {\n        allPage {\n          slug {\n            current\n          }\n        }\n      }\n    `,\n  });\n\n  const pages = data.allPage;\n\n  return {\n    paths: pages.map((p) =&gt; `/${p.slug.current}`),\n    fallback: false,\n  };\n}</code></pre>\n\n<p>If the server is already running this will reload automatically. If not, run <code>npm run dev</code> and click one of the page links on <code>http://localhost:3000</code> to see the dynamic route in action.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1e1ecd18-fdec-45a6-a64c-fc9a7eca241b/next-getstaticpaths.png\" /></p>\n<h4>Load Page Data From Sanity For The Current Page Slug In Next.js</h4>\n<p>Now that we have the page slug, we can send a request to Sanity to load the content for that page.</p>\n<p>Using the <code>getSanityContent</code> utility function, send a query that loads the current page using its slug, then pull out just the pageâ€™s data and return that in the props.</p>\n<div><pre><code>  export async function getStaticProps({ params }) {\n+   const data = await getSanityContent({\n+     query: <code>+       query PageBySlug($slug: String!) {\n+         allPage(where: { slug: { current: { eq: $slug } } }) {\n+           title\n+           content\n+         }\n+       }\n+</code>,\n+     variables: {\n+       slug: params.page,\n+     },\n+   });\n+\n+   const [pageData] = data.allPage;\n\n    return {\n      props: {\n-       slug: params.page,\n+       pageData,\n      },\n    };\n  }</code></pre></div>\n\n<p>After reloading the page, we can see that the MDX content is loaded, but it hasnâ€™t been processed yet.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6621eaa0-4208-41c3-a144-4b5696906b2d/next-mdx-sanity-page-progress.png\" /></p>\n<h4>Render MDX From A CMS In Next.js With Next-mdx-remote</h4>\n<p>To render the MDX, we need to perform two steps:</p>\n<ol>\n<li><p>For the build-time processing of MDX, we need to render the MDX to a string. This will turn the Markdown into HTML and ensure that the React components are executable. This is done by passing the content as a string into <code>renderToString</code> along with an object containing the React components we want to be available in MDX content.</p>\n</li>\n<li><p>For the client-side rendering of MDX, we hydrate the MDX by passing in the rendered string and the React components. This makes the components available to the browser and unlocks interactivity and React features.</p>\n</li>\n</ol>\n<p>While this might feel like doing the work twice, these are two distinct processes that allow us to both create fully rendered HTML markup that works without JavaScript enabled and the dynamic, client-side functionality that JavaScript provides.</p>\n<p>Make the following changes to <code>src/pages/[page].js</code> to render and hydrate MDX:</p>\n<pre><code>+ import hydrate from 'next-mdx-remote/hydrate';\n+ import renderToString from 'next-mdx-remote/render-to-string';\n  import { getSanityContent } from '../utils/sanity';\n+ import Callout from '../components/callout';\n\n- export default function Page(props) {\n-   return &lt;pre&gt;{JSON.stringify(props, null, 2)}&lt;/pre&gt;;\n+ export default function Page({ title, content }) {\n+   const renderedContent = hydrate(content, {\n+     components: {\n+       Callout,\n+     },\n+   });\n+\n+   return (\n+     &lt;div&gt;\n+       &lt;h1&gt;{title}&lt;/h1&gt;\n+       {renderedContent}\n+     &lt;/div&gt;\n+   );\n  }\n\n  export async function getStaticProps({ params }) {\n    const data = await getSanityContent({\n      query: `\n          query PageBySlug($slug: String!) {\n            allPage(where: { slug: { current: { eq: $slug } } }) {\n              title\n              content\n            }\n          }\n        `,\n      variables: {\n        slug: params.page,\n      },\n    });\n\n    const [pageData] = data.allPage;\n\n+   const content = await renderToString(pageData.content, {\n+     components: { Callout },\n+   });\n\n    return {\n      props: {\n-       pageData,\n+       title: pageData.title,\n+       content,\n      },\n    };\n  }\n\n  export async function getStaticPaths() {\n    const data = await getSanityContent({\n      query: `\n          query AllPages {\n            allPage {\n              slug {\n                current\n              }\n            }\n          }\n        `,\n    });\n\n    const pages = data.allPage;\n\n    return {\n      paths: pages.map((p) =&gt; `/${p.slug.current}`),\n      fallback: false,\n    };\n  }</code></pre>\n\n<p>After saving these changes, reload the browser and we can see the page content being rendered properly, custom React components and all!</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1b6f044e-a8ec-4c25-bc43-27155f57229e/next-mdx-sanity-page-final.png\" /></p>\n<h3>Use MDX With Sanity And Next.js For Flexible Content Workflows</h3>\n<p>Now that this code is set up, content editors can quickly write content using MDX to enable the speed of Markdown with the flexibility of custom React components, all from Sanity! The site is set up to generate all the pages published in Sanity, so unless we want to add new custom components we donâ€™t need to touch the Next.js code at all to publish new pages.</p>\n<p>What I love about this workflow is that it lets me keep my favorite parts of several tools: I really like writing content in Markdown, but my content also needs more flexibility than the standard Markdown syntax provides; I like building websites with React, but I donâ€™t like managing content in Git.</p>\n<p>Beyond this, I also have access to the huge amount of customization made available in both the Sanity and React ecosystems, which feels like having my cake and eating it, too.</p>\n<p>If youâ€™re looking for a new content management workflow, I hope you enjoy this one as much as I do!</p>\n<h3>Whatâ€™s Next?</h3>\n<p>Now that youâ€™ve got a Next site using MDX from Sanity, you may want to go further with these tutorials and resources:</p>\n<ul>\n<li>See the <a href=\"https://github.com/jlengstorf/sanity-next-mdx\">example repo used in this tutorial</a>.</li>\n<li><a href=\"https://www.netlify.com/blog/2020/11/30/how-to-deploy-next.js-sites-to-netlify/?utm_source=smashing&amp;utm_medium=mdx-sanity-next-jl&amp;utm_campaign=devex\">Deploy a Next.js Site to Netlify.</a></li>\n<li>See this approach in action on <a href=\"https://explorers.netlify.com?utm_source=smashingmag&amp;utm_medium=sanity-next-mdx-jl&amp;utm_campaign=devex\">Jamstack Explorers</a>.</li>\n<li>Check out a production implementation of this in the <a href=\"https://github.com/netlify/explorers\">Jamstack Explorers repo</a>.</li>\n<li><a href=\"https://explorers.netlify.com/learn/nextjs?utm_source=blog&amp;utm_medium=next-jl&amp;utm_campaign=devex\">Learn about Next from Cassidy Williams.</a></li>\n<li>Check out the <a href=\"https://www.sanity.io/docs\">Sanity documentation</a>.</li>\n</ul>\n<p>What will you build with this workflow? <a href=\"https://twitter.com/compose/tweet?text=Did%20you%20know%20you%20can%20write%20content%20using%20@mdx_js%20and%20store%20it%20in%20@sanity_io?%20@jlengstorf%20shows%20how%20to%20display%20MDX%20from%20a%20remote%20CMS%20using%20Next.js!&amp;url=https://www.smashingmagazine.com/2020/12/mdx-stored-sanity-next-js-website/\">Let me know on Twitter!</a></p>","author":"","siteTitle":"Articles on Smashing Magazine â€” For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"443a2e8e2c45ac719f518191fdda8a486358d1525adc3a183184511f6822792e","category":"Tech"}