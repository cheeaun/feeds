{"title":"Meet Face ID and Touch ID for the Web","link":"https://webkit.org/blog/11312/meet-face-id-and-touch-id-for-the-web/","date":1603126854000,"content":"<p>People often see passwords are the original sin of authentication on the web. Passwords can be easy to guess and vulnerable to breaches. Frequent reuse of the same password across the web makes breaches even more profitable. As passwords are made stronger and unique, they can quickly become unusable for many users. Passwords indeed look notorious, but are passwords themselves the problem, or is it their use as a sole factor for authentication?</p>\n<p>Many believe the latter, and thus <a href=\"https://en.wikipedia.org/wiki/Multi-factor_authentication\">multi-factor authentication</a> has become more and more popular. The introduction of a second factor does fix most of the security issues with passwords, but it inevitably makes the whole authentication experience cumbersome with an additional step. Therefore, multi-factor authentication has not become the de facto authentication mechanism on the web. Face ID and Touch ID for the web provides both the security guarantees of multi-factor authentication and ease of use. It offers multi-factor authentication in a single step. Using this technology, available on over a billion capable Apple devices, web developers can now broadly offer traditional multi-factor authentication with a smooth, convenient experience. And being built on top of the <a href=\"https://www.w3.org/TR/webauthn-1/\">Web Authentication API</a> makes Face ID and Touch ID phishing resistant as well.</p>\n<p>This blog post extends the content of <a href=\"https://developer.apple.com/videos/play/wwdc2020/10670/\"><em>WWDC 2020 “Meet Face ID and Touch ID for the web” session</em></a> by providing detailed examples to assist developers’ adoption of this new technology, including how to manage different user agent user interfaces, how to propagate user gestures from user-activated events to WebAuthn API calls, and how to interpret Apple Anonymous Attestation. This article will end by summarizing the unique characteristics of Apple’s platform authenticator and the current status of security key support. If you haven’t heard about WebAuthn before, you&#8217;re strongly encouraged to first watch the <a href=\"https://developer.apple.com/videos/play/wwdc2020/10670/\">WWDC 2020</a> session, which covers the basic concepts. Otherwise, please enjoy.</p>\n<h2>Managing User Experiences</h2>\n<p>Although user agents are not required to offer UI guidance to users during WebAuthn flows, the reality is that all of them do. This allows user agents to share some of the burden from websites to manage the user experience, but it creates another complexity for websites as each user agent has a different way of presenting the WebAuthn ceremony in its UI. A WebAuthn ceremony could either be the authentication process or the registration process. This section presents how WebAuthn ceremony options map to WebKit/Safari’s UI and the recommended user experience for Face ID and Touch ID for the web.</p>\n<p>One challenge is to manage different user experiences among the platform authenticator and security keys. Although the WebAuthn API allows presenting both options to the user simultaneously, it’s not the best approach. First, most users are probably only familiar with the branding of the platform authenticator, i.e., Face ID and Touch ID on Apple’s platforms, but are unfamiliar with security keys. Offering both at the same time can confuse users and make it difficult for them to decide what to do. Secondly, the platform authenticator has different behaviors and use cases from security keys. For example, Face ID and Touch ID are suitable for use as a more convenient, alternative mechanism to sign in when most security keys are not. And credentials stored in security keys can often be used across different devices and platforms while those stored in the platform authenticator are typically tied to a platform and a device. Therefore, it is better to present these two options to the user separately.</p>\n<h3>Presenting Face ID and Touch ID Alone</h3>\n<p>What follows is the recommended way to invoke Face ID and Touch ID for the web. Below is the corresponding Safari UI for registration ceremonies. Here, the Relying Party ID is picked to be displayed in the dialog.</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-2.34.11-PM.png\" alt=\"\" width=\"1820\" height=\"1238\" class=\"preserve-color wp-image-11314\" srcset=\"https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-2.34.11-PM.png 1820w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-2.34.11-PM-300x204.png 300w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-2.34.11-PM-1024x697.png 1024w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-2.34.11-PM-768x522.png 768w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-2.34.11-PM-1536x1045.png 1536w\" sizes=\"(max-width: 1820px) 100vw, 1820px\" /></figure>\n<p>Here is the corresponding code snippet to show the above dialog.</p>\n<pre><code class=\"js\"><span class=\"keyword type\">const</span> <span class=\"identifier\">options</span> <span class=\"operator\">=</span> {\n    <span class=\"identifier\">publicKey</span><span class=\"operator\">:</span> {\n        <span class=\"identifier\">rp</span><span class=\"operator\">:</span> { <span class=\"identifier\">name</span><span class=\"operator\">:</span> <span class=\"string\">\"example.com\"</span> },\n        <span class=\"identifier\">user</span><span class=\"operator\">:</span> {\n            <span class=\"identifier\">name</span><span class=\"operator\">:</span> <span class=\"string\">\"john.appleseed@example.com\"</span>,\n            <span class=\"identifier\">id</span><span class=\"operator\">:</span> <span class=\"identifier\">userIdBuffer</span>,\n            <span class=\"identifier\">displayName</span><span class=\"operator\">:</span> <span class=\"string\">\"John Appleseed\"</span>\n        },\n        <span class=\"identifier\">pubKeyCredParams</span><span class=\"operator\">:</span> [ { <span class=\"identifier\">type</span><span class=\"operator\">:</span> <span class=\"string\">\"public-key\"</span>, <span class=\"identifier\">alg</span><span class=\"operator\">:</span> <span class=\"operator\">-</span><span class=\"number\">7</span> } ],\n        <span class=\"identifier\">challenge</span><span class=\"operator\">:</span> <span class=\"identifier\">challengeBuffer</span>,\n        <span class=\"identifier\">authenticatorSelection</span><span class=\"operator\">:</span> { <span class=\"identifier\">authenticatorAttachment</span><span class=\"operator\">:</span> <span class=\"string\">\"platform\"</span> }\n    }\n};\n\n<span class=\"keyword type\">const</span> <span class=\"identifier\">publicKeyCredential</span> <span class=\"operator\">=</span> <span class=\"identifier\">await</span> <span class=\"identifier\">navigator</span>.<span class=\"identifier\">credentials</span>.<span class=\"identifier\">create</span>(<span class=\"identifier\">options</span>);\n</code></pre>\n<p>The essential option is to specify <code>authenticatorSelection: { authenticatorAttachment: \"platform\" }</code> , which tells WebKit to only invoke the platform authenticator. After the publicKeyCredential is returned, one of the best practices is to store the Credential ID in a server-set, secure, httpOnly cookie, and mark its transport as <code>\"internal\"</code>. This cookie can then be used to improve the user experience of future authentication ceremonies.</p>\n<p>To protect users from tracking, the WebAuthn API doesn’t allow websites to query the existence of credentials on a device. This important privacy feature, however, requires some extra effort for websites to store provisioned Credential IDs in a separate source and query it before the authentication ceremony. The separate source is often on the backend server. This practice works well for security keys given that they can be used across platforms. Unfortunately, it does not work for the platform authenticator as credentials can only be used on the device where they were created. A server-side source cannot tell whether or not a particular platform authenticator indeed preserves a credential. Hence, a cookie is especially useful. This cookie should not be set through the <code>document.cookie</code> API since Safari&#8217;s Intelligent Tracking Prevention caps the expiry of such cookies to seven days. It’s also important to mark those credentials as  <code>\"internal\"</code> such that websites could supply it in the authentication ceremony options to prevent WebKit from asking users for security keys at the same time.</p>\n<p>Below are two different UIs for authentication ceremonies. The first one is streamlined for the case where the user agent only has a single credential, while the second one shows how the user agent allows the user to select one of many credentials. For both cases, only <code>user.name</code> submitted in the registration ceremony is selected to display. For the second case, the order of the list is sorted according to the last used date of the credential. WebKit keeps track of the last used date. Websites thus do not need to worry about it.</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.20.07-PM.png\" alt=\"\" width=\"1820\" height=\"1238\" class=\"preserve-color wp-image-11318\" srcset=\"https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.20.07-PM.png 1820w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.20.07-PM-300x204.png 300w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.20.07-PM-1024x697.png 1024w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.20.07-PM-768x522.png 768w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.20.07-PM-1536x1045.png 1536w\" sizes=\"(max-width: 1820px) 100vw, 1820px\" /></figure>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.23.02-PM.png\" alt=\"\" width=\"1820\" height=\"1238\" class=\"preserve-color wp-image-11319\" srcset=\"https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.23.02-PM.png 1820w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.23.02-PM-300x204.png 300w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.23.02-PM-1024x697.png 1024w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.23.02-PM-768x522.png 768w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-11-at-7.23.02-PM-1536x1045.png 1536w\" sizes=\"(max-width: 1820px) 100vw, 1820px\" /></figure>\n<p>Here is the corresponding code snippet to show the above dialogs.</p>\n<pre><code class=\"js\"><span class=\"keyword type\">const</span> <span class=\"identifier\">options</span> <span class=\"operator\">=</span> {\n    <span class=\"identifier\">publicKey</span><span class=\"operator\">:</span> {\n        <span class=\"identifier\">challenge</span><span class=\"operator\">:</span> <span class=\"identifier\">challengeBuffer</span>,\n        <span class=\"identifier\">allowCredentials</span><span class=\"operator\">:</span> [\n            { <span class=\"identifier\">type</span><span class=\"operator\">:</span> <span class=\"string\">\"public-key\"</span>, <span class=\"identifier\">id</span><span class=\"operator\">:</span> <span class=\"identifier\">credentialIdBuffer1</span>, <span class=\"identifier\">transports</span><span class=\"operator\">:</span> [<span class=\"string\">\"internal\"</span>] },\n            <span class=\"comment\">// ... more Credential IDs can be supplied.\n</span>        ]\n    }\n};\n\n<span class=\"keyword type\">const</span> <span class=\"identifier\">publicKeyCredential</span> <span class=\"operator\">=</span> <span class=\"identifier\">await</span> <span class=\"identifier\">navigator</span>.<span class=\"identifier\">credentials</span>.<span class=\"identifier\">get</span>(<span class=\"identifier\">options</span>);\n</code></pre>\n<p>To be noted, even though an improvement over WebKit can be made such that <code>transports: [\"internal\"]</code> is not necessary to prevent WebKit from asking users for security keys as long as all allowed credentials are found within the platform authenticator, it is for the happy path only. In the case where no credentials are found, this extra property can tell WebKit to show an error message instead of asking the user for security keys.</p>\n<h3>Presenting Face ID and Touch ID along with Security Keys</h3>\n<p>Despite the fact that the following usage is discouraged, WebKit/Safari has prepared dedicated UI to allow the user to select a security key in addition to the platform authenticator. Below is the one for registration ceremonies.</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.44.52-AM.png\" alt=\"\" width=\"1820\" height=\"1238\" class=\"preserve-color wp-image-11323\" srcset=\"https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.44.52-AM.png 1820w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.44.52-AM-300x204.png 300w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.44.52-AM-1024x697.png 1024w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.44.52-AM-768x522.png 768w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.44.52-AM-1536x1045.png 1536w\" sizes=\"(max-width: 1820px) 100vw, 1820px\" /></figure>\n<p>The above dialog can be obtained by deleting <code>authenticatorSelection: { authenticatorAttachment: \"platform\" }</code> from the registration ceremony code snippet above.</p>\n<figure><img loading=\"lazy\" src=\"https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.45.23-AM.png\" alt=\"\" width=\"1820\" height=\"1238\" class=\"preserve-color wp-image-11324\" srcset=\"https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.45.23-AM.png 1820w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.45.23-AM-300x204.png 300w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.45.23-AM-1024x697.png 1024w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.45.23-AM-768x522.png 768w, https://webkit.org/wp-content/uploads/Screen-Shot-2020-08-12-at-1.45.23-AM-1536x1045.png 1536w\" sizes=\"(max-width: 1820px) 100vw, 1820px\" /></figure>\n<p>The above dialog will be shown if any entry in the <code>allowCredentials</code> array from the authentication ceremony code snippet above doesn’t have the  <code>transports: [\"internal\"]</code> property.</p>\n<p>To be noted, security keys can be used immediately in both cases after the UI is shown. “Use Security Key” and “Account from Security Key” options are there to show instructions of how to interact with security keys.</p>\n<h3>Specifying allowCredentials or not</h3>\n<p><code>allowCredentials</code> is optional for authentication ceremonies. However, omitting it will result in undetermined behavior in WebKit/Safari’s UI. If credentials are found, the authentication ceremony UI above will be shown. If no credentials are found, WebKit will ask the user for their security keys. Therefore, it is highly recommended not to omit this option.</p>\n<h2>Propagating User Gestures</h2>\n<p>Unsolicited permission prompts are annoying. Mozilla has conducted surveys [<a href=\"https://blog.nightly.mozilla.org/2019/04/01/reducing-notification-permission-prompt-spam-in-firefox/\">1</a>, <a href=\"https://blog.mozilla.org/futurereleases/2019/11/04/restricting-notification-permission-prompts-in-firefox/\">2</a>] that verify this. Even though WebAuthn prompts are not as often seen on the web as notification prompts today, this situation will change with the release of Face ID and Touch ID for the web.</p>\n<p>Websites don’t ask for notification permission for fun. They ask because notifications can bring users back to their sites and increase their daily active users metric. A similar financial incentive could be found with WebAuthn prompts especially when platform authenticators are available as a fulfilled authentication request results in a high fidelity, persistent unique identifier of the user. This is a universal truth about authentication and that is why many sites ask for it before users even interact with the site. Though it is inevitable that WebAuthn credential will be leveraged to serve targeted ads to users, at least a similar protection that Mozilla did in Firefox for notification permission prompts can be utilized to make those WebAuthn prompts less annoying to users, which is to require user gestures for the WebAuthn API to eliminate annoying ‘on load’ prompts.</p>\n<p>We foresaw this problem some time ago and filed an <a href=\"https://github.com/w3c/webauthn/issues/1293\">issue</a> on the WebAuthn specification, but it didn’t get much traction back then. One reason is that it is a breaking change. Another reason is that the risk is not as high with security keys since they are not that popular and not always attached to the platform. The amount of unsolicited prompts has been surprisingly low. The situation is different with the release of Face ID and Touch ID for the web. So, Face ID and Touch ID for the web require user gestures to function. (User gestures are not required for security keys for backward compatibility.)</p>\n<p>A <em>user gesture</em> is an indicator to signal WebKit that the execution of the current JavaScript context is a direct result of a user interaction, or more precisely from a handler for a user activated event, such as a <code>touchend</code>, <code>click</code>, <code>doubleclick</code>, or <code>keydown</code> event [<a href=\"https://webkit.org/blog/6784/new-video-policies-for-ios/\">3</a>]. Requiring user gestures for the WebAuthn API means API calls must happen within the above JavaScript context. Normally, the user gesture will not be propagated to any async executors within the context. Since it is popular for websites to fetch a challenge asynchronously from a server right before invoking WebAuthn API, WebKit allows WebAuthn API to accept user gestures propagated through XHR events and the Fetch API. Here are examples of how websites can invoke Face ID and Touch ID for the web from user activated events.</p>\n<h3>Calling the API Directly from User Activated Events</h3>\n<pre><code class=\"js\"><span class=\"comment\">// Fetching the challengeBuffer before the onclick event.\n</span>\n<span class=\"identifier\">button</span>.<span class=\"identifier\">addEventListener</span>(<span class=\"string\">\"click\"</span>, <span class=\"identifier\">async</span> () <span class=\"operator\">=</span><span class=\"operator\">&gt;</span> {\n    <span class=\"keyword type\">const</span> <span class=\"identifier\">options</span> <span class=\"operator\">=</span> {\n        <span class=\"identifier\">publicKey</span><span class=\"operator\">:</span> {\n            ...\n            <span class=\"identifier\">challenge</span><span class=\"operator\">:</span> <span class=\"identifier\">challengeBuffer</span>,\n            ...\n        }\n    };\n\n    <span class=\"keyword type\">const</span> <span class=\"identifier\">publicKeyCredential</span> <span class=\"operator\">=</span> <span class=\"identifier\">await</span> <span class=\"identifier\">navigator</span>.<span class=\"identifier\">credentials</span>.<span class=\"identifier\">create</span>(<span class=\"identifier\">options</span>);\n});\n</code></pre>\n<h3>Propagating User Gestures Through XHR Events</h3>\n<pre><code class=\"js\"><span class=\"identifier\">button</span>.<span class=\"identifier\">addEventListener</span>(<span class=\"string\">\"click\"</span>, () <span class=\"operator\">=</span><span class=\"operator\">&gt;</span> {\n    <span class=\"keyword type\">const</span> <span class=\"identifier\">xhr</span> <span class=\"operator\">=</span> <span class=\"keyword operator\">new</span> <span class=\"identifier\">XMLHttpRequest</span>();\n    <span class=\"identifier\">xhr</span>.<span class=\"identifier\">onreadystatechange</span> <span class=\"operator\">=</span> <span class=\"identifier\">async</span> <span class=\"keyword type\">function</span>() {\n        <span class=\"keyword control\">if</span> (<span class=\"keyword\">this</span>.<span class=\"identifier\">readyState</span> <span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">4</span> <span class=\"operator\">&amp;</span><span class=\"operator\">&amp;</span> <span class=\"keyword\">this</span>.<span class=\"identifier\">status</span> <span class=\"operator\">=</span><span class=\"operator\">=</span> <span class=\"number\">200</span>) {\n            <span class=\"keyword type\">const</span> <span class=\"identifier\">challenge</span> <span class=\"operator\">=</span> <span class=\"keyword\">this</span>.<span class=\"identifier\">responseText</span>;\n            <span class=\"keyword type\">const</span> <span class=\"identifier\">options</span> <span class=\"operator\">=</span> {\n                <span class=\"identifier\">publicKey</span><span class=\"operator\">:</span> {\n                    ...\n                    <span class=\"identifier\">challenge</span><span class=\"operator\">:</span> <span class=\"identifier\">hexStringToUint8Array</span>(<span class=\"identifier\">challenge</span>), <span class=\"comment\">// a custom helper\n</span>                    ...\n                }\n            };\n\n            <span class=\"keyword type\">const</span> <span class=\"identifier\">publicKeyCredential</span> <span class=\"operator\">=</span> <span class=\"identifier\">await</span> <span class=\"identifier\">navigator</span>.<span class=\"identifier\">credentials</span>.<span class=\"identifier\">create</span>(<span class=\"identifier\">options</span>);\n        }\n    };\n    <span class=\"identifier\">xhr</span>.<span class=\"identifier\">open</span>(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"/WebKit/webauthn/challenge\"</span>, <span class=\"keyword literal\">true</span>);\n    <span class=\"identifier\">xhr</span>.<span class=\"identifier\">setRequestHeader</span>(<span class=\"string\">\"Content-type\"</span>, <span class=\"string\">\"application/x-www-form-urlencoded\"</span>);\n    <span class=\"identifier\">xhr</span>.<span class=\"identifier\">send</span>();\n});\n</code></pre>\n<h3>Propagating User Gestures Through Fetch API</h3>\n<pre><code class=\"js\"><span class=\"identifier\">button</span>.<span class=\"identifier\">addEventListener</span>(<span class=\"string\">\"click\"</span>, <span class=\"identifier\">async</span> () <span class=\"operator\">=</span><span class=\"operator\">&gt;</span> {\n    <span class=\"keyword type\">const</span> <span class=\"identifier\">response</span> <span class=\"operator\">=</span> <span class=\"identifier\">await</span> <span class=\"identifier\">fetch</span>(<span class=\"string\">\"/WebKit/webauthn/challenge\"</span>, { <span class=\"identifier\">method</span><span class=\"operator\">:</span> <span class=\"string\">\"POST\"</span> });\n    <span class=\"keyword type\">const</span> <span class=\"identifier\">challenge</span> <span class=\"operator\">=</span> <span class=\"identifier\">await</span> <span class=\"identifier\">response</span>.<span class=\"identifier\">text</span>();\n\n    <span class=\"keyword type\">const</span> <span class=\"identifier\">options</span> <span class=\"operator\">=</span> {\n        <span class=\"identifier\">publicKey</span><span class=\"operator\">:</span> {\n            ...\n            <span class=\"identifier\">challenge</span><span class=\"operator\">:</span> <span class=\"identifier\">hexStringToUint8Array</span>(<span class=\"identifier\">challenge</span>), <span class=\"comment\">// a custom helper\n</span>            ...\n        }\n    };\n    <span class=\"keyword type\">const</span> <span class=\"identifier\">publicKeyCredential</span> <span class=\"operator\">=</span> <span class=\"identifier\">await</span> <span class=\"identifier\">navigator</span>.<span class=\"identifier\">credentials</span>.<span class=\"identifier\">create</span>(<span class=\"identifier\">options</span>);\n});\n</code></pre>\n<p>To be noted, readable streams cannot propagate user gestures yet (related <a href=\"https://bugs.webkit.org/show_bug.cgi?id=214722\">bug</a>). Also, the user gesture will expire after 10 seconds for both XHR events and Fetch API.</p>\n<h3>Easter Egg: Propagating User Gestures Through setTimeout</h3>\n<pre><code class=\"js\"><span class=\"identifier\">button</span>.<span class=\"identifier\">addEventListener</span>(<span class=\"string\">\"click\"</span>, () <span class=\"operator\">=</span><span class=\"operator\">&gt;</span> {\n    <span class=\"identifier\">setTimeout</span>(<span class=\"identifier\">async</span> () <span class=\"operator\">=</span><span class=\"operator\">&gt;</span> {\n        <span class=\"keyword type\">const</span> <span class=\"identifier\">options</span> <span class=\"operator\">=</span> { ... };\n        <span class=\"keyword type\">const</span> <span class=\"identifier\">publicKeyCredential</span> <span class=\"operator\">=</span> <span class=\"identifier\">await</span> <span class=\"identifier\">navigator</span>.<span class=\"identifier\">credentials</span>.<span class=\"identifier\">create</span>(<span class=\"identifier\">options</span>);\n    }, <span class=\"number\">500</span>);\n});\n</code></pre>\n<p>The user gesture in the above example will expire after 1 second.</p>\n<p>On iOS 14, iPadOS 14 and macOS Big Sur Beta Seed 1, only the very first case is supported. Thanks to early feedback from developers, we were able to identify limitations and add the later cases. This also helped us recognize that user gestures are not a well understood concept among web developers. Therefore, we are going to contribute to the HTML specification and help establish a well established concept of a user gesture for consistency among browser vendors. Depending on how it goes, we might reconsider expanding the user gesture requirement to security keys.</p>\n<h2>Interpreting Apple Anonymous Attestation</h2>\n<p>Attestation is an optional feature which provides websites a cryptographic proof of the authenticator&#8217;s provenance such that websites that are restricted by special regulations can make a trust decision. Face ID and Touch ID for the web offers Apple Anonymous Attestation. Once verified, this attestation guarantees that an authentic Apple device performed the WebAuthn registration ceremony, but it does not guarantee the operating system running on that device is untampered. If the operating system is untampered, it also guarantees that the private key of the just generated credential is protected by the <a href=\"https://support.apple.com/guide/security/secure-enclave-overview-sec59b0b31ff/web\">Secure Enclave</a> and the usage of the private key is guarded with Face ID or Touch ID. (A note: the guard falls back to device passcode if biometric fails multiple times in a row.)</p>\n<p>Apple Anonymous Attestation is first of its kind, providing a service like an <a href=\"https://www.w3.org/TR/webauthn/#anonymization-ca\">Anonymization CA</a>, where the authenticator works with a cloud operated CA owned by its manufacturer to dynamically generate per-credential attestation certificates such that no identification information of the authenticator will be revealed to websites in the attestation statement. Furthermore, among data relevant to the registration ceremony, only the public key of the credential along with a hash of the concatenated authenticator data and client data are sent to the CA for attestation, and the CA will not store any of these. This approach makes the whole attestation process privacy preserving. In addition, this approach avoids the security pitfall of <a href=\"https://www.w3.org/TR/webauthn/#basic-attestation\">Basic Attestation</a> that the compromising of a single device results in revoking certificates from all devices with the same attestation certificate.</p>\n<h3>Enabling Apple Anonymous Attestation</h3>\n<pre><code class=\"js\"><span class=\"keyword type\">const</span> <span class=\"identifier\">options</span> <span class=\"operator\">=</span> {\n    <span class=\"identifier\">publicKey</span><span class=\"operator\">:</span> {\n        ...\n        <span class=\"identifier\">attestation</span><span class=\"operator\">:</span> <span class=\"string\">\"direct\"</span>, <span class=\"comment\">// the essential option\n</span>        ...\n    }\n};\n\n<span class=\"keyword type\">const</span> <span class=\"identifier\">publicKeyCredential</span> <span class=\"operator\">=</span> <span class=\"identifier\">await</span> <span class=\"identifier\">navigator</span>.<span class=\"identifier\">credentials</span>.<span class=\"identifier\">create</span>(<span class=\"identifier\">options</span>);\n</code></pre>\n<h3>Verifying the Statement Format</h3>\n<p>This is the definition of the Apple Anonymous Attestation statement format. <a href=\"https://github.com/w3c/webauthn/issues/1453\">Issue 1453</a> is tracking the progress of adding this statement format to the WebAuthn standard.</p>\n<pre><code>$$attStmtType //= (\n                       fmt: \"apple\",\n                       attStmt: appleStmtFormat\n                   )\n\nappleStmtFormat = {\n                       x5c: [ credCert: bytes, * (caCert: bytes) ]\n                   }\n</code></pre>\n<p>The semantics of the above fields are as follows:<br />\n<strong>x5c</strong><br />\n<strong><strong>credCert</strong></strong> followed by its certificate chain, each encoded in X.509 format.<br />\n<strong>credCert</strong><br />\nThe credential public key certificate used for attestation, encoded in X.509 format.</p>\n<p>Here is the verification procedure given inputs <em>attStmt</em>, <em>authenticatorData</em> and <em>clientDataHash</em>:</p>\n<ol>\n<li>Verify that <em>attStmt</em> is valid CBOR conforming to the syntax defined above and perform CBOR decoding on it to extract the contained fields.</li>\n<li>Concatenate <em>authenticatorData</em> and <em>clientDataHash</em> to form <em>nonceToHash</em>.</li>\n<li>Perform SHA-256 hash of <em>nonceToHash</em> to produce <em>nonce</em>.</li>\n<li>Verify <em>nonce</em> matches the value of the extension with OID ( 1.2.840.113635.100.8.2 ) in <em>credCert</em>. The <em>nonce</em> here is used to prove that the attestation is live and to protect the integrity of the <em>authenticatorData</em> and the client data.</li>\n<li>Verify credential public key matches the Subject Public Key of <em>credCert</em>.</li>\n<li>If successful, return implementation-specific values representing attestation type Anonymous CA and attestation trust path <em>x5c</em>.</li>\n</ol>\n<p>The final step is to verify <em>x5c</em> is a valid certificate chain starting from the <em>credCert</em> to the <a href=\"https://www.apple.com/certificateauthority/private/\">Apple WebAuthn root certificate</a>, which then proves the attestation. (This step is usually shared among different types of attestations that utilize <em>x5c</em> [<a href=\"https://www.w3.org/TR/webauthn/#registering-a-new-credential\">4</a>].) To be noted, the AAGUID is all zeros even if the attestation is enabled as all Apple devices that support Face ID and Touch ID for the web should have the same properties as explained at the beginning of this section and no other devices can request Apple Anonymous Attestation.</p>\n<h2>Unique Characteristics of Apple’s Platform Authenticator</h2>\n<p>Here is a summary about unique characteristics of Apple’s platform authenticator, i.e., Face ID and Touch ID for the web.</p>\n<ul>\n<li>Different option set results in different UI, and therefore please specify it wisely.</li>\n<li>Only RP ID and <a href=\"http://user.name/\">user.name</a> are selected to display in the UI.</li>\n<li>User gestures are required to invoke the platform authenticator.</li>\n<li>Apple Anonymous Attestation is available. Use it only if attestation is necessary for you.</li>\n<li>AAGUID is all zero even if attestation is used.</li>\n<li>Face ID and Touch ID for the web is available in Safari, SFSafariViewController and ASWebAuthenticationSession on iOS 14, iPadOS 14 and macOS Big Sur. For macOS, Safari 14 with downlevel OS will not get this feature because the attestation relies on a new system framework.</li>\n<li>All public key credentials generated by the platform authenticator are resident keys regardless of what option is specified.</li>\n<li>Credentials can only be cleared for all via Safari &gt; History &gt; Clear History&#8230; on Mac Safari or Settings &gt; Safari &gt; Clear History and Website Data on iOS &amp; iPadOS.</li>\n<li>The signature counter is not implemented and therefore it is always zero. Secure Enclave is used to prevent the credential private key from leaking instead of a software safeguard.</li>\n</ul>\n<h2>Current Status of Security Key Support</h2>\n<p>Besides the introduction of Face ID and Touch ID for the web, iOS 14, iPadOS 14 and Safari 14 on all supported macOS also have improved security key support including PIN entry and account selection. Here is a list of features that are currently supported. All of them have been supported since iOS 13.3, iPadOS 13.3 and Safari 13 except the two aforementioned.</p>\n<ul>\n<li>All MUST features in WebAuthn Level 1 and all optional features except CollectedClientData.tokenBinding and most of the extensions. Only the appid extension is supported.</li>\n<li>All CTAP 2.0 authenticator API except setPin and changePin.</li>\n<li>USB, Lightning, and NFC transports are supported on capable devices.</li>\n<li>U2F security keys are supported via CTAP 2.0 but not CTAP 1/U2F JS.</li>\n<li>Like Face ID and Touch ID for the web, security key support is available in Safari, SFSafariViewController and ASWebAuthenticationSession.</li>\n</ul>\n<h2>Feedback</h2>\n<p>In this blog post, we introduced Face ID and Touch ID for the web. We believe it is a huge leap forward for authentication on the web. It serves as a great alternative way to sign in, especially for traditional multi-factor authentication mechanisms. With the assistance of this technology, we believe multi-factor authentication will replace sole-factor password as the de facto authentication mechanism on the web. Developers, please start testing this feature today and let us know how it works for you by sending feedback on Twitter (<a href=\"https://twitter.com/webkit\">@webkit</a>, <a href=\"https://twitter.com/alanwaketan\">@alanwaketan</a>, <a href=\"https://twitter.com/jonathandavis\">@jonathandavis</a>) or by <a href=\"https://bugs.webkit.org/\">filing a bug</a>.</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"ca5db47cec02c1f92529b373ca68d522f0a4d70f8c79061c080fb63bcb5d7bbb","category":"Tech"}