{"title":"Wall of Text #11: C Array and Fraps","link":"https://blog.whs.in.th/node/3427","date":1586677269000,"content":"<div class=\"wp-block-jetpack-markdown\"><p>น้องเค้ามีคำถามจากการบ้านว่า</p>\n<blockquote>\n<p>จงเปรียบเทียบระหว่าง Array ในภาษาเก่าๆ กับ Python list</p>\n</blockquote>\n<p>ผมชอบคำถามนี้นะ คำตอบที่เค้าเขียนคือ</p>\n<blockquote>\n<p>ในภาษา C สมาชิกของ Array ทั้งหมดจะต้องเป็น data type เดียวกันทั้งหมด และขนาดของ Array จะตายตัว แต่ใน Python list สามารถคละ data type กันได้ และสามารถเปลี่ยนขนาดของ Array ได้โดยการเพิ่มหรือลบสมาชิก</p>\n</blockquote>\n<p>ที่น่าสนใจคือ จริงๆ แล้ว C Array ไม่ได้มีขนาดตายตัว&#8230;. มันไม่มีขนาดด้วยซ้ำ</p>\n<p>Array ในภาษา C จริงๆ แล้วมันคือ Pointer ซึ่งเก็บ<strong>ที่อยู่</strong>ของข้อมูล การใช้ Pointer ในภาษา C จะประมาณนี้</p>\n</div>\n\n\n\n<iframe height=\"600px\" width=\"100%\" src=\"https://repl.it/repls/StarchyYellowishDeveloper?lite=true\" scrolling=\"no\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" sandbox=\"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"></iframe>\n\n\n\n<div class=\"wp-block-jetpack-markdown\"><p>ถ้าลองรันดูจะเห็นว่า output คือ 10 ถึงเราจะไม่ได้แก้ x ตรงๆ แต่เราแก้ผ่าน pointer แทน</p>\n<p>คำสั่ง <code>*x_ptr</code> จะเป็นการอ่านค่าที่ตำแหน่งที่ <code>x_ptr</code> ชี้ไปอยู่ ซึ่งจริงๆ แล้วคำสั่งนี้มีค่าเท่ากับ <code>x_ptr[0]</code>&#8230; แล้ว <code>x_ptr[1]</code> คืออะไรล่ะ?</p>\n<p><code>x_ptr[1]</code> มีค่าเท่ากับ <code>*(x_ptr + 1)</code> เนื่องจากใน C สมาชิกทุกตัวใน array จะอยู่ใน memory ตำแหน่งที่ติดกันไปเรื่อยๆ และสมาชิกทุกตัวมีขนาดเท่ากัน (เพราะเป็น data type เดียวกัน) ดังนั้นถ้าเราทราบที่อยู่ของสมาชิกตัวแรก ตัวถัดไปก็คือเลื่อนไปจากสมาชิกตัวแรกเท่ากับขนาดของสมาชิก 1 ตัว</p>\n<p>ดังนั้นตัวแปรที่เก็บ C array จริงๆ แล้วไม่ได้เก็บ array แต่เก็บตำแหน่งของสมาชิกตัวแรกเท่านั้น ส่วนการประกาศ array จริงๆ แล้วก็คือการจองพื้นที่พอให้เก็บสมาชิกใน array ตามจำนวนที่ขอ และคืนตำแหน่งของสมาชิกตัวแรกมาให้</p>\n<p>แต่จริงๆ แล้ว เราสามารถอ่านหรือเขียนค่าไปเกินกว่าพื้นที่ที่ขอได้เช่นเดียวกัน เนื่องจาก C ไม่มีการเก็บไว้ด้วยซ้ำว่า array มีขนาดเท่าไร (แต่ไม่การันตีผลลัพท์นะว่าถ้าอ่านเขียนเกินพื้นที่ที่จองไว้จะได้ผลอย่างไร)</p>\n<h2>Portable assembly</h2>\n<p>หลังฉากของภาษา C แล้วน่าสนใจว่ามันเป็นภาษาที่ไม่ค่อยสูงกว่า assembly เท่าไรนัก มันไม่พยายามซ่อนการทำงานของคอมพิวเตอร์ ซึ่งก็ตรงตามสิ่งที่ผู้สร้าง C คิดไว้คือมันเป็นเพียงแค่ Portable Assembly</p>\n<p>ซึ่งในภาษา C เองก็ยังมีคำสั่ง <a href=\"https://gcc.gnu.org/onlinedocs/gcc-5.2.0/gcc/Basic-Asm.html\"><code>__asm__</code></a> ที่เอาไว้เขียน assembly code ผสมกับภาษา C ได้เมื่อจำเป็น</p>\n<p>และคำสั่งนี้ก็มีใช้อยู่ในโค้ดจริงๆ ด้วย เช่นถ้าเราไปอ่านโค้ดของ <a href=\"https://github.com/balabit/FFmpeg/blob/a75c056386c5586894b966157341c9a4f55ce2ab/libavcodec/x86/h264_i386.h\">H.264 decoder</a> ก็จะเห็นว่าเค้าใช้ Assembly ผสมกับโค้ด C เพราะการ decode video นั้นอาจจะใช้<a href=\"https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions\">ฟีเจอร์เฉพาะของ CPU</a> เข้ามาช่วยได้ ซึ่ง compiler อาจจะไม่สามารถแปลงโค้ด C เป็นคำสั่ง CPU พวกนี้ได้ (<a href=\"https://en.wikipedia.org/wiki/Automatic_vectorization\">*</a>)</p>\n<h2>Hardware acceleration</h2>\n<p>หลายๆ อย่างที่คอมพิวเตอร์เราทำอยู่นั้น ถึงแม้ว่าคอมพิวเตอร์จะเร็วขึ้นแต่การที่ไม่มี hardware พิเศษมารองรับก็อาจจะทำให้ทำงานได้ช้าหรือทำงานไม่ได้เลย</p>\n<p>GPU ของ Raspberry Pi นั้นสามารถถอดรหัส video H.264 (mp4) ได้สบายๆ หลายคนเอา Raspberry Pi มาลง Kodi ดูหนังซึ่งก็จะเห็นว่าภาพก็ลื่นดี แต่ถ้าโปรแกรมที่ใช้นั้นไม่รองรับการใช้ hardware acceleration แล้วก็จะพบว่า CPU ของ Raspberry Pi decode ไฟล์ mp4 ไม่ไหวเลย</p>\n<p>บน PC ก็เช่นเดียวกัน ถ้าเราดูไฟล์วิดีโอ MP4 ในเครื่อง จะเห็นว่า CPU load จะไม่ถึง 10% เท่านั้น แต่ถ้าลองดู YouTube 4K จะพบว่า CPU ขึ้นไปสูงถึง 50-100% เลยทีเดียว เนื่องจากฟอร์แมต VP9 (ในขณะที่เขียนนี้) hardware หลายๆ รุ่นยังไม่รองรับการถอดรหัส VP9 เลยจะต้องใช้พลัง CPU ประมวลผล ซึ่งนอกจากจะหน่วงเครื่องแล้วยังเปลืองแบตเตอรี่อีกด้วย</p>\n</div>\n\n\n\n<figure class=\"wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio\"><div class=\"wp-block-embed__wrapper\">\n<iframe class='youtube-player' width='840' height='473' src='https://www.youtube.com/embed/zCLOJ9j1k2Y?version=3&#038;rel=1&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;fs=1&#038;hl=en-US&#038;autohide=2&#038;wmode=transparent' allowfullscreen='true' style='border:0;' sandbox='allow-scripts allow-same-origin allow-popups allow-presentation'></iframe>\n</div><figcaption>อย่าลืมปรับเป็น 4k 60fps</figcaption></figure>\n\n\n\n<p>สมัย Windows XP ถ้าใครเคย Capture โปรแกรมวิดีโอด้วยปุ่ม print screen ก็จะเห็นว่ากรอบที่เล่น video จะเป็นจอดำ หรือเวลากด Print screen บนเกม Full screen ก็เช่นกัน วิธีแก้ไขก็คือใช้โปรแกรมพิเศษที่จับภาพหน้าจอเกมได้ เช่น <a href=\"https://www.fraps.com\">Fraps</a></p>\n\n\n\n<p>ที่เป็นอย่างนี้ก็เพราะ Video หรือเกมก็แล้วแต่นั้น ภาพถูกสร้างขึ้นบนการ์ดจอโดยตรงโดยไม่ได้ผ่าน desktop เมื่อเรากด print screen จึงจะเห็นแค่ฉากหลังดำๆ เท่านั้น</p>\n\n\n\n<p>ตั้งแต่ Windows Vista เป็นต้นมา Desktop compositing (Aero) เป็นที่นิยมมากขึ้นซึ่งทำให้ประสบการณ์ใช้งาน desktop ดีขึ้น ภาพไม่กระพริบ เวลาลากโปรแกรมไม่กระตุก (ข้อเสียคือเกมที่รันใน Windowed mode จะไม่สามารถรันเร็วกว่าเฟรมเรทของ Compositor ได้ ซึ่งถ้าใครใช้จอ 120Hz อาจจะต้องรันเกมใน Full screen แทน) ซึ่ง Desktop compositing นี้ทำงานบนการ์ดจอทำให้การทำ Print screen เปลี่ยนไปและเรามักจะสามารถ screenshot ทุกอย่างบนหน้าจอได้หมดแล้ว นอกเหนือจากเกม Full screen</p>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<p>ผมคิดว่าการศึกษาการทำงานของคอมพิวเตอร์เป็นเรื่องที่น่าสนใจมาก ถ้ามีคนถามว่าทำไม print screen แล้วจอดำ เราจะได้เข้าใจเหตุผลว่ามันไม่ใช่ &#8220;เพราะคุณกด print screen จอเกมไม่ได้ถ้าไม่ได้ใช้ Fraps&#8221; แต่เพราะภาพมันอยู่ที่การ์ดจอแล้วเรา print screen บน CPU ต่างหากล่ะ</p>","author":"whs","siteTitle":"Quietly Verbose","siteHash":"5f972a6fe70a917eb1b1aa165b3cb2be8a9465af33ab38bf05f34c55c0e40587","entryHash":"a10eaecc65c3314fc15c00c9971a40b0d7e8b3a9ea64f5f852d66ea209c040da","category":"Thai"}